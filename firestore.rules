rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /** ========= Utils ========= **/
    function isAuth() { return request.auth != null; }
    function isPathOwner(userId) { return isAuth() && request.auth.uid == userId; }

    function hasRole(r) {
      return isAuth() && (
        request.auth.token.role == r ||
        (request.auth.token.roles != null && request.auth.token.roles.hasAny([r])) ||
        (r == 'admin' && request.auth.token.admin == true)
      );
    }

    function isAdmin() { return hasRole('admin'); }
    function isBeta()  { return hasRole('betas'); }
    function isUser()  { return hasRole('user') || isBeta(); }
    function only(allowed) { return request.resource.data.keys().hasOnly(allowed); }
    function keep(field) { return request.resource.data[field] == resource.data[field]; }

    /** ========= /users/{uid} ========= **/
    match /users/{userId} {
      function validSchemaOnCreate() {
        return only(['uid','displayName','email','role',
                     'hasCompletedOnboarding','termsAccepted','createdAt']) &&
               request.resource.data.uid == userId &&
               request.resource.data.role in ['user','betas','admin'];
      }

      function validSchemaOnUpdate() {
        return only(['uid','displayName','email','role',
                     'hasCompletedOnboarding','termsAccepted','createdAt']) &&
               keep('uid') && keep('createdAt') &&
               (isAdmin() || request.resource.data.role == resource.data.role) &&
               keep('email');
      }

      allow read:   if isPathOwner(userId) || isAdmin();
      allow create: if (isPathOwner(userId) || isAdmin()) && validSchemaOnCreate();
      allow update: if (isPathOwner(userId) || isAdmin()) && validSchemaOnUpdate();
      allow delete: if isPathOwner(userId) || isAdmin();
    }

    /** ========= /users/{uid}/subcoleções ========= **/
    match /users/{userId}/{documents=**} {
      allow read, write: if isPathOwner(userId) || isAdmin();
    }
    
        /** ========= /ultra_batch_jobs/{jobId} ========= **/
    match /ultra_batch_jobs/{jobId} {
      // Permite leitura se o usuário for o dono do job ou um admin.
      // Usa get() para buscar o documento e verificar o campo 'user_id'.
      allow read: if (isPathOwner(get(/databases/$(database)/documents/ultra_batch_jobs/$(jobId)).data.user_id) || isAdmin());
      
      // Apenas o backend (via service account) pode criar, atualizar ou deletar.
      // Para o cliente, essas operações são negadas.
      allow write: if false;

      /** ========= /ultra_batch_jobs/{jobId}/results/{resultId} ========= **/
      // Regra para a subcoleção de resultados.
      match /results/{resultId} {
        // A permissão de leitura é herdada da regra pai.
        // Um usuário que pode ler o job, também pode ler os resultados.
        allow read: if (isPathOwner(get(/databases/$(database)/documents/ultra_batch_jobs/$(jobId)).data.user_id) || isAdmin());

        // Nega escrita na subcoleção também.
        allow write: if false;
      }
    }

    /** ========= /archived_chats/{archId} ========= **/
    match /archived_chats/{archId} {
      // Permite create e update (para batch.set() que pode ser ambíguo)
      // Simplificado: removida verificação chatExistsForOwner que pode falhar em batch
      allow create, update: if isAuth()
        && request.auth.uid == request.resource.data.deletedBy
        && (
          isAdmin() ||
          request.resource.data.chatOwnerId == request.auth.uid
        );

      allow read: if isAdmin();
      allow delete: if false;
    }

    /** ========= NOVAS COLEÇÕES =========
     * → Aqui não há bloqueio geral, então qualquer nova coleção criada
     *    funcionará automaticamente.
     * → Se quiser limitar alguma, basta criar um novo bloco match.
     * Exemplo:
     * match /reports/{reportId} {
     *   allow read, write: if isAdmin();
     * }
     */
  }
}